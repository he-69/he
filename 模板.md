## 输入输出优化

```c++
	#pragma GCC optimize(2) // O2优化
cout << setiosflags(ios::fixed) << setprecision(2); // 保留小数位数
	ios_base::sync_with_stdio(false);cin.tie(0);cout.tie(0);
```

## 威佐夫博弈

```c++
int Wythoff(int a,int b) { 
	int x = min(a,b);
    int y = max(a,b);
    double k = (double)y - x;
    int kk = (int)(k * (1 + sqrt(5)) / 2);
    if(kk == x) return 0; //先手必输
    else return 1;     //先手必赢
}
```

## 优先队列

```c++
struct node {
	int priority ,value;
	friend bool operator< (node a1,node a2) {
		return a1.priority < a2.priority;   // < 为从大到小排序         > 为从小到大排序
	}
};

priority_queue<node> q;

priority_queue<int> q;          // 最大堆  大的优先
priority_queue<int,vector<int>,greater<int> > q;   // 最小堆   小的优先
```

## 01背包

```c++
#include<bits/stdc++.h>
using namespace std;
int f[1005];          //若是装入容积为 V f[0...n] = 0;   
                      //若刚刚好装入V容积 f[0] = 0,f[1...n] = -∞; 
int v[1005];     //物品价值 
int c[105];      //物品空间
int main(){
   	int n,i,j,V;
   	scanf("%d%d",&V,&n);     //V表示空间  n表示物品数 
   	for(i = 0;i < n;i++){
   		scanf("%d%d",&c[i],&v[i]);
	}
	for(i = 0;i < n;i++){
		for(j = V;j >= c[i];j--){
			if(f[j] < f[j - c[i]] + v[i]) f[j] = f[j - c[i]] + v[i];
		}
	}
	printf("%d",f[V]);
	return 0;
}
```

## 完全背包

```c++
#include<bits/stdc++.h>
using namespace std;
int c[10005],v[10005];
int f[100005];
int main(){
	int i ,j ,n ,k ,V ,ans = 0;
	cin >> V >> n;
	for(i = 0;i < n;i++){
		cin >> c[i] >> v[i];
	}
	for(i = 0;i < n;i++){
		for(j = c[i];j <= V ;j++){
			f[j] = max(f[j - c[i]] + v[i],f[j]);
		}
	}
	for(i = 1;i <= V ;i++){
		ans = max(ans,f[i]);
	}
	cout << ans;
	return 0;
}
```

## 树的重心

```c++
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const ll N = 3e5 + 5;
struct yyy{
    int to,next;
} p[N << 1];
int head[N],vis[N],son[N];
int n,tot = 0,ans = 0,size = 0x7fffffff;
void add(int u,int v) {
    p[++tot].to = v;
    p[tot].next = head[u];
    head[u] = tot;
}
void dfs(int x){
    vis[x] = 1;
    son[x] = 0;
    int k = 0;
    for(int i = head[x];i;i = p[i].next){
        int t = p[i].to;
        if(!vis[t]){
            dfs(t);
            son[x] += son[t] + 1;
            k = max(k,son[t] + 1);
        }
    }
    k = max(k,n - son[x] - 1);
    if((x < ans && k == size) || k < size){
        ans = x;
        size = k;
    }
}
int main(){
    ios_base::sync_with_stdio(false);cin.tie(0);cout.tie(0);
    int i,u,v;
    cin >> n;
    for(i = 1;i < n;i++) {
        cin >> u >> v;
        add(u,v);
        add(v,u);
    }
    dfs(1);
    cout << ans << '\n';
    return 0;
}
```

## manacher算法

```c++
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const ll N = 2e5 + 5;
char s[N],ss[N];
int p[N],o[N];
int l[N],r[N];
void init() {
	int i;
	ss[0] = '&';ss[1] = '#';
	int len = strlen(s);
	int j = 2;
	for(i = 0;i < len;i++) {
		ss[j++] = s[i];
		ss[j++] = '#';
	}
	ss[j++] = '%';
	ss[j] = '\0';
}
void manacher() {
	init();
	int len = strlen(ss);
	int mx = 0,mid = 0;
	int maxlen = 0,sum = 0;
	for (int i = 1; i < len; i++) {
		if (mx > i) p[i] = min(mx - i, p[2 * mid - i]);
		else p[i] = 1;
		while (ss[i + p[i]] == ss[i - p[i]]) p[i]++;
		if (p[i] + i > mx) {
			mx = p[i] + i;
			mid = i;
		}
		maxlen = max(maxlen,p[i] - 1);   //最长回文子串长度 
		sum += p[i] / 2;               //回文子串个数 
	}
}
int main(){
	int i,j,T,n,m,k;
	scanf("%s",s);
    manacher();
	return 0;
}
```

## 字典树

```c++
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const ll N = 5e5 + 5;
int tot,i,n,q,ans;
int trie[N][26];
int sum[N];        //计算以此为前缀的数量
//int End[N];      //计算以当前root为结尾的字符串的数量
string s;
void insert(string s) {   //插入树
	int root = 0;
	int len = s.length();
    for(int i = 0;i < len;i++) {
        int x = s[i] - 'a';
        if(!trie[root][x]) {  //现在插入的字母在之前同一节点处未出现过 
            trie[root][x] = ++tot;  //字母插入一个新的位置，否则不做处理 
        }
        root = trie[root][x];   //为下个字母的插入做准备  
        sum[root]++;
    }
    //End[root]++;       //标志该单词末位字母的尾结点，非0时为存在
}
void find(string s) {
	ans = 0;
	int root = 0;
    int len = s.length();
    for (int i = 0;i < len;i++) {
        int x = s[i] - 'a';
        if (!trie[root][x])return;
        root = trie[root][x];
        /*if(End[root]) {
        	ans += End[root];
        }*/
    }
    //ans -= End[root];
    ans += sum[root];
}
int main() {
	ios_base::sync_with_stdio(false);cin.tie(0);cout.tie(0);
	cin >> n;
	for(i = 0;i < n;i++) {
		cin >> s;
		insert(s);
	}
	cin >> q;
	while(q--) {
		cin >> s;
		find(s);
		cout << ans << '\n';
	}
	return 0;
}
```

## 后缀自动机

```c++
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N = 3e5 + 10;      //字符串长度 
const int maxc = 26;
char s[N];
struct Suffix_Automaton {       //打*的不一定用到 
    int next[N << 1][maxc];  //状态转移(尾部加一个字符的下一个状态)
    int len[N << 1]; //最长子串的长度(该节点子串数量=len[x]-len[link[x]])
    int link[N << 1];   //后缀链接(最短串前部减少一个字符所到达的状态)
//	int cnt[N << 1];   //被后缀连接的数(*) 
    int id; //结点编号
    int last; //最后结点
    int endpos[N << 1]; // endpos数(一类子串的数量)
    int a[N];
    int b[N << 1];
    int dp[N << 1];
//  int ans[N << 1];
//  ll d[N << 1];   //d[i]表示从状态i出发，不同的子串的数目,即不同的路径数
    void init() {	//初始化
        for(int i = 1; i <= id; i++) { //常规初始化 
            link[i] = len[i] = 0;
            memset(next[i],0,sizeof(next[i]));
            endpos[i] = 0;
            a[i] = b[i] = 0;
        }
//		for(int i = 1;i <= id;i++) {     //非常规初始化 
//			d[i] = 0;
//		}
        last = id = 1; //1表示root起始点 空集
    }
    //SAM建图
    void add(int c) {     //插入字符，为字符ascll码值
        int x = ++id; //创建一个新结点x;
        len[x] = len[last] + 1; //  长度等于最后一个结点+1
        endpos[x] = 1;  //接受结点子串除后缀连接还需加一
        int p;  //第一个有C转移的结点;
        for (p = last; p && !next[p][c]; p = link[p]) {
            next[p][c] = x;//沿着后缀连接 将所有没有字符c转移的节点直接指向新结点
        }
        if (!p) {   //全部都没有c的转移 直接将新结点后缀连接到起点
            link[x] = 1;
            //	cnt[1]++;  
        }
        else {
            int q = next[p][c];    //p通过c转移到的结点
            if (len[p] + 1 == len[q]) {//pq是连续的
                link[x] = q;
                //	cnt[q]++; //将新结点后缀连接指向q即可,q结点的被后缀连接数+1
            }
            else {
                int nq = ++id;   //不连续 需要复制一份q结点
                len[nq] = len[p] + 1;   //令nq与p连续
                link[nq] = link[q];   //因后面link[q]改变此处不加cnt
                memcpy(next[nq], next[q], sizeof(next[q]));  //复制q的信息给nq
                for (; p && next[p][c] == q; p = link[p]) {
                    next[p][c] = nq;    //沿着后缀连接 将所有通过c转移为q的改为nq
                }
                link[q] = link[x] = nq; //将x和q后缀连接改为nq
                //cnt[nq] += 2; //  nq增加两个后缀连接	
            }
        }
        last = x;  //更新最后处理的结点	
    }
    ll getSubNum() {	//求不相同子串数量
        ll ans = 0;
        for (int i = 2; i <= id; i++) {
            ans += len[i]-len[link[i]];	//一状态子串数量等于len[i]-len[link[i]]
        }
        return ans;
    }
    void getTP(int Len) {//对sam的节点按照len，从小到大排序重新标号，即给定节点的拓扑序
        for(int i = 1;i <= id;i++) a[len[i]]++;
        for(int i = 1;i <= Len;i++) a[i] += a[i-1];
        for(int i = 1;i <= id;i++) b[a[len[i]]--] = i;
    }
    void getendpos() {//求每类子串的数量 ,即endpos集合的大小 
        for(int i = id;i >= 1;i--) { //按拓扑序遍历 
            int e = b[i];
            endpos[link[e]]+=endpos[e];
        }
    }
    void get_len_max(int Len) {//求长度为i的出现次数最多的子串的出现次数 
        for(int i = 1;i <= id;i++) dp[len[i]] = max(dp[len[i]],endpos[i]);
        for(int i = Len-1;i >= 1;i--) dp[i] = max(dp[i],dp[i + 1]);
        for(int i = 1;i <= Len;i++) printf("%d\n",dp[i]);
    }
    /*
    void LCS1(char s[],int Len) {           //求两个串的最长公共子串
        int ans = 0,cnt = 0;
        int now = 1;
        for(int i = 0;i < Len;i++) {
              int c = s[i] - 'a';
              if(next[now][c]) {
                  cnt++;
                  now = next[now][c];
            }
            else {
                  while(now && !next[now][c]) now = link[now];
                  if(!now) cnt = 0,now = 1;
                  else cnt = len[now] + 1,now = next[now][c];
            }
            ans = max(ans,cnt);
        }
        printf("%d\n",ans);
    } 
    */

    /*
    void init_ans() {
        for(int i = 1;i <= id;i++) ans[i] = len[i];
    }
    void LCS2(char s[],int Len) {     //求多个串的最长公共子串 
        for(int i = 1;i <= id;i++) dp[i]=0;
        int cnt = 0;
        int now = 1;
        for(int i = 0;i < Len;i++) {
              int c = s[i] - 'a';
              if(next[now][c]){
                  cnt++;
                  now = next[now][c];
            }
            else {
                  while(now && !next[now][c]) now = link[now];
                  if(!now) cnt = 0,now = 1;
                  else cnt = len[now] + 1,now = next[now][c];
            }
            dp[now] = max(dp[now],cnt);
        }
        for(int i = id;i >= 1;i--) {
            int e = b[i];
            dp[link[e]] = max(dp[link[e]],min(dp[e],len[link[e]]));
        }
        for(int i = 1;i <= id;i++) ans[i] = min(ans[i],dp[i]);
    }
    void get_LCS2_ans() {
        int cnt = 0;
        for(int i = 1;i <= id;i++) cnt = max(cnt,ans[i]);
        printf("%d\n",cnt);
    }
    */

    /*
    void solve1() { //求出现次数为k的子串种数 
        ll ans = 0;
        for(int i = 1;i <= id;i++) {
            if(endpos[i] == K) {
                ans += len[i] - len[link[i]];
            }
        }
        printf("%lld\n",ans);
    }
    */

    /*
    void solve1() {//求出现次数A<=K<=B的子串种数 
        for(int i = id;i > 1;i--) {
            int v = b[i];
            if(endpos[v] >= A && endpos[v] <= B) d[v]++;
            for(int j = 0;j < 26;j++) {
                if(next[v][j]) d[v] += d[next[v][j]];
            }
        }
        ll ans = 0;
        for(int i = 0;i < 26;i++) {
            if(next[1][i]) ans += d[next[1][i]];
        }
        printf("%lld\n",ans);
    }
    */

    /*
    void solve2() {//求出现次数 >= k的子串的最大长度 
        int ans = 0;
        for(int i = 1;i <= id;i++) {
            if(endpos[i] >= K){
                ans = max(ans,len[i]);
            }
        }
        printf("%d\n",ans);
    }
    */

} sam;
int main() {
    scanf("%s",s);
    int len = strlen(s);
    sam.init();
    for(int i = 0;i < len;i++) {
        sam.add(s[i] - 'a');
    }
    sam.getTP(len);
    sam.getendpos();
    sam.get_len_max(len);
    return 0;
}
```

## 线段树

```c++
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const ll N = 1e5 + 5;
ll mod,a[N],sum[N << 2],add[N << 2],mul[N << 2]; // sum 为区间和  add 为加量  mul 为乘量
ll lc(ll id) {
    return id << 1;
}
ll rc(ll id) {
    return id << 1 | 1;
}
void pushdown(ll id,ll l,ll r) {
    ll mid = (l + r) >> 1;
    sum[lc(id)] = (sum[lc(id)] * mul[id] + add[id] * (mid - l + 1)) % mod;
    sum[rc(id)] = (sum[rc(id)] * mul[id] + add[id] * (r - mid)) % mod;
    mul[lc(id)] = (mul[lc(id)] * mul[id]) % mod;
    mul[rc(id)] = (mul[rc(id)] * mul[id]) % mod;
    add[lc(id)] = (add[lc(id)] * mul[id] + add[id]) % mod;
    add[rc(id)] = (add[rc(id)] * mul[id] + add[id]) % mod;
    add[id] = 0;
    mul[id] = 1;
    return;
}
ll build(ll id,ll l,ll r) {
    mul[id] = 1;
    add[id] = 0;
    if(l == r) {
        return sum[id] = a[l];
    }
    ll mid = (l + r) >> 1;
    sum[lc(id)] = build(lc(id),l,mid);
    sum[rc(id)] = build(rc(id),mid + 1,r);
    sum[id] = (sum[lc(id)] + sum[rc(id)]) % mod;
    return sum[id];
}
void update(ll id,ll a,ll b,ll l,ll r,ll k,ll op) {
    if (a <= l && r <= b) {
        if(op == 1) {              // 乘操作
            add[id] = (add[id] * k) % mod;
            mul[id] = (mul[id] * k) % mod;
            sum[id] = (sum[id] *  k) % mod;
        }
        else if(op == 2) {         // 加操作
            add[id] = (add[id] + k) % mod;
            sum[id] = (sum[id] +  k * (r - l + 1)) % mod;
        }
        return;
    }
    pushdown(id,l,r);
    ll mid = (l + r) >> 1;
    if(a <= mid) update(lc(id),a,b,l,mid,k,op);
    if(b > mid)  update(rc(id),a,b,mid + 1,r,k,op);
    sum[id] = sum[lc(id)] + sum[rc(id)];
    sum[id] %= mod;
}
ll query(ll id,ll a,ll b,ll l,ll r) {
    if(a <= l && r <= b) {
        return sum[id];
    }
    pushdown(id,l,r);
    ll ans = 0;
    ll mid = (l + r) >> 1;
    if(a <= mid) ans = (ans + query(lc(id),a,b,l,mid)) % mod;
    if(b > mid)  ans = (ans + query(rc(id),a,b,mid + 1,r)) % mod;
    return ans;
}
int main() {
    ios_base::sync_with_stdio(false);cin.tie(0);cout.tie(0);
    ll i,k,n,m,op;
    cin >> n >> mod;
    for(i = 1;i <= n;i++) {
        cin >> a[i];
        a[i] %= mod;
    }
    build(1,1,n);
    cin >> m;
    while(m--) {
        cin >> op;
        if(op == 3) {
            ll a,b;
            cin >> a >> b;
            cout << query(1,a,b,1,n) << '\n';
        }
        else {
            ll a,b;
            cin >> a >> b >> k;
            update(1,a,b,1,n,k,op);
        }
    }
    return 0;
}
```



## KMP算法

```c++
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N = 3e5 + 10;      //字符串长度
string s,t;
int _next[N];     // 回溯数组  同时也为 t 的第i个前缀的公共前后缀长度
void Getnext() {
   int i,k = 0;
   _next[0] = _next[1] = 0;
   int len = t.length();
   for(i = 1;i < len;i++) {
       while(k && t[i] != t[k]) k = _next[k];
       if(t[i] == t[k]) _next[i + 1] = ++k;   //当两个字符相同时，就跳过
       else _next[i + 1] = 0;
   }
}
void KMP() {
	int slen = s.length();
    int tlen = t.length();
    int k = 0;
    for (int i = 0; i < slen; i++) {
        while (k && t[k] != s[i]) {//s和t不匹配，且k > -1(表示s和t有部分匹配)
            k = _next[k];   //往前回溯
        }
        if (t[k] == s[i]) {
        	k++;
        }
        if (k == tlen) {   //说明k移动到ptr的最末端
            cout << i - tlen + 2 << '\n';
            return;        // 只输出第一个 若输出所有将删除
        }
    }
    cout << -1;        // s 中不存在子串 t
}
int main() {
    cin >> s >> t;
    Getnext();   //计算_next数组
    KMP();
    return 0;
}
```

## 欧拉筛

```c++
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N = 1e6 + 5;
int prime[N];    // 素数集合      prime[0] 表示 素数个数
int phi[N];      // 表示不超过n且与n互质的正整数的个数
void phi_prime() {
    phi[0] = phi[1] = 1;
    for(int i = 2;i < N;i++) {
        if(!phi[i]) {
            prime[++prime[0]] = i;
            phi[i] = i - 1;     // phi[i] == i - 1  为素数
        }
        for(int j = 1;j <= prime[0] && i * prime[j] < N;j++) {
            phi[prime[j] * i] = 1;
            if(i % prime[j] == 0) {
                phi[i * prime[j]] = phi[i] * prime[j];
                break;
            }
            else {
                phi[i * prime[j]] = phi[i] * (prime[j] - 1);
            }
        }
    }
}

int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    phi_prime();
    int n;
    while(cin >> n && n) {
        cout << phi[n] << '\n';
    }
    return 0;
}
```

## 求$\sum_{i = 1}^{n}\sum_{j=1}^{m}[gcd(i,j)==k]$(未打印)

莫比乌斯函数 $\large \mu(n)= \begin{cases} 1, & {n=1} \\ (-1)^k, & {n无平方数因子, k为质因子个数} \\ 0, & {n有平方数因子} \end{cases}$

```c++
ll prime[N], phi[N];
ll mu[N];   // 莫比乌斯函数
void phi_prime() {
    phi[0] = phi[1] = mu[1] = 1;
    for(int i = 2;i < N;i++) {
        if(!phi[i]) {
            prime[++prime[0]] = i;
            phi[i] = i - 1;
            mu[i] = -1;
        }
        for(int j = 1;j <= prime[0] && i * prime[j] < N;j++) {
            phi[prime[j] * i] = 1;
            if(i % prime[j] == 0) {
                phi[i * prime[j]] = phi[i] * prime[j];
                mu[i * prime[j]] = 0;
                break;
            } else {
                phi[i * prime[j]] = phi[i] * (prime[j] - 1);
                mu[i * prime[j]] = -mu[i];
            }
        }
    }
    for(int i = 2;i < N;i++) mu[i] += mu[i - 1];
}
ll get_ans(ll n, ll m, ll k) {
    if(n > m) swap(n, m);
    n /= k;
    m /= k;
    ll res = 0, r;
    for(int l = 1;l <= n;l = r + 1) {
        r = min(n / (n / l), m / (m / l));
        res += (mu[r] - mu[l - 1]) * (n / l) * (m / l);
    }
    return res;
}
```

## 求$\sum_{i = 1}^{n}\sum_{j=1}^{m}[gcd(i,j)==prime]$(未打印)

```c++
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N = 1e7 + 5;
ll n, m, k;
ll a[N], b[N];
ll prime[N], phi[N];
ll mu[N], sum[N];   // mu 为莫比乌斯函数
void phi_prime() {
    phi[0] = phi[1] = mu[1] = 1;
    for(int i = 2;i < N;i++) {
        if(!phi[i]) {
            prime[++prime[0]] = i;
            phi[i] = i - 1;
            mu[i] = -1;
        }
        for(int j = 1;j <= prime[0] && i * prime[j] < N;j++) {
            phi[prime[j] * i] = 1;
            if(i % prime[j] == 0) {
                phi[i * prime[j]] = phi[i] * prime[j];
                mu[i * prime[j]] = 0;
                break;
            } else {
                phi[i * prime[j]] = phi[i] * (prime[j] - 1);
                mu[i * prime[j]] = -mu[i];
            }
        }
    }
    for(int i = 1;i <= prime[0];i++) {      // 预处理质数
        for(int j = 1;prime[i] * j < N;j++) {
            sum[j * prime[i]] += mu[j];
        }
    }
    for(int i = 1;i < N;i++) sum[i] += sum[i - 1];  
}

ll get_ans(ll n, ll m, ll k) {
    if(n > m) swap(n, m);
    n /= k;
    m /= k;
    ll res = 0, r;
    for(int l = 1;l <= n;l = r + 1) {
        r = min(n / (n / l), m / (m / l));
        res += (sum[r] - sum[l - 1]) * (n / l) * (m / l);
    }
    return res;
}

int main() {
    ios_base::sync_with_stdio(0);
    cin >> m;
    cout << get_ans(n, m, 1) << '\n';
    return 0;
}
```

## 求$\sum_{i = 1}^{n}\sum_{j=1}^{m}gcd(i,j)$(未打印)

```c++
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const ll N = 1e6 + 5;
ll n, m;
ll prime[N], phi[N];
ll mu[N];   // 莫比乌斯函数
void phi_prime() {
    phi[0] = phi[1] = mu[1] = 1;
    for(int i = 2;i < N;i++) {
        if(!phi[i]) {
            prime[++prime[0]] = i;
            phi[i] = i - 1;
            mu[i] = -1;
        }
        for(int j = 1;j <= prime[0] && i * prime[j] < N;j++) {
            phi[prime[j] * i] = 1;
            if(i % prime[j] == 0) {
                phi[i * prime[j]] = phi[i] * prime[j];
                mu[i * prime[j]] = 0;
                break;
            } else {
                phi[i * prime[j]] = phi[i] * (prime[j] - 1);
                mu[i * prime[j]] = -mu[i];
            }
        }
    }
    for(int i = 2;i < N;i++) mu[i] += mu[i - 1];
}

ll get_ans(ll n, ll m) {
    ll mi = min(n, m);
    ll res = 0, r;
    for(int l = 1;l <= n;l = r + 1) {
        r = min(n / (n / l), m / (m / l));
        res += (mu[r] - mu[l - 1]) * (n / l) * (m / l);
    }
    return res;
}

int main() {
    phi_prime();
    cin >> n >> m;
    ll mi = min(n, m);
    ll ans = 0, r;
    for(ll l = 1;l <= mi;l = r + 1) {
        r = mi / (mi / l);
        ll d = (l + r) * (r - l + 1) / 2;
        ll res = get_ans(n / l, m / l);
        ans = ans + d * res;
    }
    cout << ans << '\n';
    return 0;
}
```

## 求$\sum_{i = 1}^{n}\sum_{j=i+1}^{n}gcd(i,j)$

```c++
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const ll N = 1e6 + 5;
ll n,prime[N],phi[N];
ll ans[N];         // 存储 gcd_sum
void phi_prime() {
    phi[0] = phi[1] = 1;
    for(int i = 2;i <= N;i++) {
        if(!phi[i]) {
            prime[++prime[0]] = i;
            phi[i] = i - 1;
        }
        for(int j = 1;j <= prime[0] && i * prime[j] <= N;j++) {
            phi[prime[j] * i] = 1;
            if(i % prime[j] == 0) {
                phi[i * prime[j]] = phi[i] * prime[j];
                break;
            } else {
                phi[i * prime[j]] = phi[i] * (prime[j] - 1);
            }
        }
    }
    for(int i = 1;i <= N;i++) ans[i] = phi[i];
    for(int i = 2;i * i <= N;i++) {
        ans[i * i] += phi[i] * i;
        for(int j = i + 1;j * i <= N;j++)
            ans[j * i] += phi[i] * j + phi[j] * i;
    }
    ans[1] = 0;
    for(int i = 2;i <= N;i++) ans[i] += ans[i - 1];
}

int main() {
    phi_prime();
    while(cin >> n) {
        cout << ans[n] << '\n';
    }
    return 0;
}
```

## 后缀数组+LCP( 最长公共前缀 )

```c++
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const ll N = 1e6 + 5;
char s[N];
int c[N],x[N],y[N];        // c数组是桶   基数排序 
int sa[N],rk[N],height[N]; //sa为后缀数组 rk为排名数组  height为 后缀i和i-1的公共前缀长度数组
int n,m;
void get_sa() {      // s字符串下标从1开始
	for(int i = 1;i <= n;i++) ++c[x[i] = s[i]];
	//x[i]是第i个元素的第一关键字 
    for(int i = 2;i <= m;i++) c[i] += c[i-1]; 
    //做c的前缀和，我们就可以得出每个关键字最多是在第几名 
    for(int i = n;i >= 1;i--) sa[c[x[i]]--] = i; 
    for(int k = 1;k <= n;k <<= 1){
        int num = 0;
        for(int i = n - k + 1;i <= n;i++) y[++num]=i;
        //y[i]表示第二关键字排名为i的数，第一关键字的位置 
		//第n-k+1到第n位是没有第二关键字的 所以排名在最前面 
        for(int i = 1;i <= n;i++) if(sa[i] > k) y[++num] = sa[i] - k;
        //排名为i的数 在数组中是否在第k位以后
		//如果满足(sa[i]>k) 那么它可以作为别人的第二关键字，就把它的第一关键字的位置添加进y就行了
		//所以i枚举的是第二关键字的排名，第二关键字靠前的先入队 
        for(int i = 1;i <= m;i++) c[i]=0;
        //初始化c桶 
        for(int i = 1;i <= n;i++) ++c[x[i]];
        //因为上一次循环已经算出了这次的第一关键字 所以直接加就行了 
        for(int i = 2;i <= m;i++) c[i] += c[i-1];//第一关键字排名为1~i的数有多少个 
        for(int i = n;i >= 1;i--) sa[c[x[y[i]]]--] = y[i];
        //因为y的顺序是按照第二关键字的顺序来排的 
        //第二关键字靠后的，在同一个第一关键字桶中排名越靠后 
        //基数排序 
        swap(x,y);
		//这里不用想太多，因为要生成新的x时要用到旧的，就把旧的复制下来，没别的意思 
        x[sa[1]] = 1;num = 1;
        for(int i = 2;i <= n;i++)
            x[sa[i]] = (y[sa[i]] == y[sa[i - 1]] && y[sa[i] + k] == y[sa[i-1] + k]) ? num : ++num;
        //因为sa[i]已经排好序了，所以可以按排名枚举，生成下一次的第一关键字 
        if(num == n) break;
        m = num;
        //这里就不用那个130了，因为都有新的编号了 
    }
    for(int i = 1;i < n;i++) printf("%d ",sa[i]);
    printf("%d\n",sa[n]);
}
void get_height() {
    int k = 0;
    for(int i = 1;i <= n;i++) rk[sa[i]]=i;
    for(int i = 1;i <= n;i++) {
        if (rk[i] == 1) continue;//第一名height为0 
        if (k) k--;//h[i]>=h[i-1]+1;
        int j = sa[rk[i]-1];
        while (j + k <= n && i + k <= n && s[i + k] == s[j + k]) k++;
        height[rk[i]] = k;//h[i]=height[rk[i]];
    }
    for(int i = 1;i < n;i++) printf("%d ",height[i]);
    printf("%d\n",height[n]);
}

/*void get_sa() {         // s字符串的下标从0开始
	for(int i = 0;i < n;i++) c[x[i] = s[i]]++;
    for(int i = 1;i < m;i++) c[i] += c[i-1]; 
    for(int i = n - 1;i >= 0;i--) sa[--c[x[i]]] = i; 
    for(int k = 1;k <= n;k <<= 1) {
        int num = 0;
        for(int i = n - k;i < n;i++) y[num++] = i;
        for(int i = 0;i < n;i++) if(sa[i] >= k) y[num++] = sa[i] - k;
        for(int i = 0;i < m;i++) c[i] = 0;
        for(int i = 0;i < n;i++) c[x[y[i]]]++;
        for(int i = 1;i < m;i++) c[i] += c[i-1];
        for(int i = n - 1;i >= 0;i--) sa[--c[x[y[i]]]] = y[i];
        swap(x,y);
        x[sa[0]] = 0;num = 1;
        for(int i = 1;i < n;i++)
            x[sa[i]] = (y[sa[i]] == y[sa[i - 1]] && y[sa[i] + k] == y[sa[i - 1] + k]) ? num - 1 : num++;
        if(num == n) break;
        m = num;
    }
    for(int i = 0;i < n;i++) {
    	if(i == n - 1)printf("%d\n",sa[i]);
    	else printf("%d ",sa[i]);
    }
}
void get_height() {
    int k = 0;                    //LCP(i,k)=min(LCP(i,j),LCP(j,k))
    for(int i = 0;i < n;i++) rk[sa[i]] = i;
    for(int i = 0;i < n;i++) {
        if (rk[i] == 0) continue;
        if (k) k--;
        int j = sa[rk[i] - 1];
        while (j + k < n && i + k < n && s[i + k] == s[j + k]) k++;
        height[rk[i]] = k;
    }
    for(int i = 0;i < n;i++) {
    	if(i == n - 1)printf("%d\n",height[i]);
    	else printf("%d ",height[i]);
    }
}*/

int main() {
    gets(s+1);
    n = strlen(s+1);
	m = 130;   //因为这个题不读入n和m所以要自己设
	//n表示原字符串长度，m表示字符个数，ascll 128个 
	//我们第一次读入字符直接不用转化，按原来的ascll码来就可以了 
	//因为转化数字和大小写字母还得分类讨论，怪麻烦的 
    get_sa();   //得到后缀数组 
    get_height();    //得到公共前缀长度数组 
}
```

## 最小生成树(Prim)

```c++
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const ll N = 2e5 + 5;
struct yyy{
	ll v,w;
};
vector<yyy> g[N];
ll d[N],v[N],i,n,m;
void prim() {
	memset(d,0x3f3f3f,sizeof d);
	memset(v,0,sizeof v);
	d[1] = 0;
	for(int i = 1;i < n;i++) {
		int x = 0;
		for(int j = 1;j <= n;j++) {
			if (!v[j] && (x == 0 || d[j] < d[x])) x = j;
		}
		v[x] = 1;
		for(int j = 0;j < g[x].size();j++) {
			if (!v[g[x][j].v]) d[g[x][j].v] = min(d[g[x][j].v],g[x][j].w);
		}
	}
    ll ans = 0;
	for(i = 1;i <= n;i++) {
		if(d[i] == 0x3f3f3f) {
			cout << "不能构成树" << '\n'; 
            return;
		}
		ans += d[i];
	}
	cout << ans;
}
int main() {
	ios_base::sync_with_stdio(false);cin.tie(0);cout.tie(0);
    cin >> n >> m;
	for(i = 1;i <= m;i++) {
		ll u,v,w;
		cin >> u >> v >> w;
		g[u].push_back({v,w});
		g[v].push_back({u,w});
	}
	prim();
    return 0;
}
```

## 最小生成树(Kruskal)

```c++
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const ll N = 2e5 + 5;
ll f[N],i,n,m;
ll find(ll x) {
	while(x != f[x])x = f[x] = f[f[x]];
	return x;
}
struct yyy{
	ll u,v,w;
}p[N];
bool cmp(yyy a,yyy b) {
    return a.w < b.w;
}
void Kruskal() {
    ll cnt = 1;
    ll ans = 0;
    for(i = 1;i <= n;i++) f[i] = i;
    for(i = 0;i < m;i++) {
        ll x = find(p[i].u);
        ll y = find(p[i].v);
        if(x == y)continue;
        cnt++;
        ans += p[i].w;
        f[x] = y;
        if(cnt == n)break;
    }
    cout << ans;
}
int main() {
	ios_base::sync_with_stdio(false);cin.tie(0);cout.tie(0);
	cin >> n >> m;
	for(i = 0;i < m;i++) {
		cin >> p[i].u >> p[i].v >> p[i].w;
	}
    sort(p,p + m,cmp);
    Kruskal();
    return 0;
}
```

## LCA(倍增)

```c++
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N = 1e6 + 5;
ll n, m, root;
ll h[N], fa[N][22], lg[N];
vector<ll> g[N];

void init() {
    for (int i = 1; i <= n; i++) { // lg 数组存储 log_2(i) + 1 取整的值
        lg[i] = lg[i >> 1] + 1;
    }
}
void dfs(int now, int f) {
    fa[now][0] = f;
    h[now] = h[f] + 1;
    for (int i = 1; i <= lg[h[now]]; i++) {
        fa[now][i] = fa[fa[now][i - 1]][i - 1];
    }
    for(int e : g[now]){
        if(e != f) dfs(e, now);
    }
}
int LCA(int x, int y) {
    if (h[x] < h[y]) swap(x, y);
    while (h[x] > h[y]) {
        x = fa[x][lg[h[x] - h[y]] - 1];
    }
    if (x == y) return x;
    for (int k = lg[h[x]] - 1; k >= 0; k--) {
        if (fa[x][k] != fa[y][k]) {
            x = fa[x][k];
            y = fa[y][k];
        }
    }
    return fa[x][0];
}

int main() {
    ios_base::sync_with_stdio(false);
    cin >> n >> m >> root;  // root 为树的根节点
    for (int i = 1; i < n; i++) {
        int u, v;
        cin >> u >> v;
        g[u].push_back(v);
        g[v].push_back(u);
    }
    init();
    dfs(root, 0);
    for (int i = 1; i <= m; i++) {
        int u, v;
        cin >> u >> v;
        cout << LCA(u, v) << '\n';
    }
    return 0;
}
```

## LCA(Tarjan)

```c++
#include<bits/stdc++.h>
using namespace std;
const int N = 1e6 + 5;
struct node {
    int to,num,next;
}e[N << 1],w[N << 1];
int head_1[N],tot;
void add_1(int u,int v) {
    e[++tot].to = v;
    e[tot].next = head_1[u];
    head_1[u] = tot;
}
int head_2[N],cnt;
void add_2(int u,int v,int num) {
    w[++cnt].to = v;
    w[cnt].num = num;
    w[cnt].next = head_2[u];
    head_2[u] = cnt;
}
int f[N],vis[N];
int find(int x) {
    if(f[x] == x) return x;
    return f[x] = find(f[x]);
}
int ans[N];
void tarjan(int u) {
    f[u] = u;
    vis[u] = 1;
    for(int i = head_1[u];i;i = e[i].next) {
        if(!vis[e[i].to]) {
            tarjan(e[i].to);
            f[e[i].to] = u;
        }
    }
    for(int i = head_2[u];i;i = w[i].next) {
        if(vis[w[i].to]) {
            ans[w[i].num] = find(w[i].to);
        }
    }
}
int main() {
    ios_base::sync_with_stdio(false);
        cin.tie(0);
        cout.tie(0);
    int i,n,m,q;
    cin >> n >> m >> q;
    for(i = 1;i <= n;i++) f[i] = i;
    for(i = 1;i <= m;i++) {
        int u,v;
        cin >> u >> v;
        add_1(u,v);
        add_1(v,u);
    }
    for(i = 1;i <= q;i++) {
        int u,v;
        cin >> u >> v;
        add_2(u,v,i);
        add_2(v,u,i);
    }
    tarjan(1);
    for(i = 1;i <= n;i++) {
        cout << ans[i] << "\n";
    }
    return 0;
}
```

## 解同余方程(扩展欧几里德算法)

```c++
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
ll ex_gcd(ll a, ll b, ll& x, ll& y) {
    if (b == 0) {
        x = 1;
        y = 0;
        return a;
    }
    ll d = ex_gcd(b, a % b, x, y);
    ll temp = x;
    x = y;
    y = temp - a / b * y;
    return d;
}
bool liEu(ll a, ll b, ll c, ll& x, ll& y) {
    ll d = ex_gcd(a, b, x, y);
    if (c % d != 0) return false;
    ll k = c / d;
    x *= k;
    y *= k;
    return true;
}
int main() {
    ios_base::sync_with_stdio(false);cin.tie(0);cout.tie(0);
    ll a,b,c,x,y;
    cin >> a >> b >> c;     // 同余方程 ax = c(mod b)  ----> ax + by = c
    liEu(a,b,c,x,y);        // 扩展欧几里德算法 c = gcd(a,b)
    b = b / __gcd(a, b);
    x = (x % b + b) % b;    // x 为最小正整数解
    cout << x << '\n';
    return 0;
}
```

## 乘法逆元

```c++
#include <bits/stdc++.h>
using namespace std;
const int N = 1e6 + 5;
int n,mod;
int qpow(int a,int b) {
    int x = 1;
    while(b) {
        if(b & 1) x = x * a % mod;
        a = a * a % mod;
        b >>= 1;
    }
    return x;
}
void ex_gcd(int a, int b, int& x, int& y) {  // ax = 1 (mod b)    x 为 a 的逆元
    if (b == 0) {
        x = 1, y = 0;
        return;
    }
    ex_gcd(b, a % b, y, x);
    y -= a / b * x;
}
int inv[N];
void get_inv() {               // 求线性 1~n 的逆元   p 为模数
    inv[1] = 1;
    for (int i = 2; i <= n; i++) inv[i] = (mod - mod / i) * inv[mod % i] % mod;
}
int a[N],s[N],sv[N];
void get_inv() {              // 求任意 n 个数的逆元 a 数组为元素  p 为模数
    s[0] = 1;                         // s 数组为前缀积
    for (int i = 1; i <= n; i++) s[i] = s[i - 1] * a[i] % mod;
    sv[n] = qpow(s[n], mod - 2);
    for (int i = n; i >= 1; i--) sv[i - 1] = sv[i] * a[i] % mod;
    for (int i = 1; i <= n; i++) inv[i] = sv[i] * s[i - 1] % mod;
}
int main() {
	ios_base::sync_with_stdio(false);cin.tie(0);cout.tie(0);
    cin >> n >> mod;
    get_inv();
    for(int i = 1;i <= n;i++) cout << inv[i] << '\n';
    return 0;
}
```

## 二维矩阵滑动窗口

```c++
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N = 5e3 + 5;
const int mod = 20101009;
int t[N][N];      // 输入的矩阵
int ans[N][N];    // 存 a*b 的窗口内最大值
deque<int> q(N);

void solve(int n, int len, int *arr, int *ans) {
    q.clear();
    for (int i = 1; i <= n; i++) {
        while (!q.empty() && arr[q.back()] < arr[i]) {
            q.pop_back();
        }
        while (!q.empty() && q.front() < i - len + 1) {
            q.pop_front();
        }
        q.push_back(i);
        if (i + 1 >= len) {
            ans[i - len + 1] = arr[q.front()];
        }
    }
}


int main() {
    ios::sync_with_stdio(false);
    int n, m, a, b;
    cin >> n >> m >> a >> b;         // 矩阵大小 和 窗口大小
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= m; j++) {
            cin >> t[i][j];
        }
    }
    for (int i = 1; i <= n; i++) {
        solve(m, b, t[i], ans[i]);
    }
    int len = a;
    for (int i = 1; i <= m; i++) {
        q.clear();
        for (int j = 1; j <= n; j++) {
            while (!q.empty() && ans[q.back()][i] < ans[j][i]) {
                q.pop_back();
            }
            while (!q.empty() && q.front() < j - len + 1) {
                q.pop_front();
            }
            q.push_back(j);
            if (j + 1 >= len) {
                ans[j - len + 1][i] = ans[q.front()][i];
            }
        }
    }
    ll sum = 0;
    for (int i = 1; i <= n - a + 1; i++) {
        for (int j = 1; j <= m - b + 1; j++) {
            sum += ans[i][j];
        }
    }
    cout << sum << '\n';
    return 0;
}
```

## 二分图最大匹配

```c++
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N = 2e5 + 5;
int n, m, t;
int mch[N], vis[N];       // mch 存当前配对的对象   0 表示无
vector<int> g[N];
bool dfs(int u,int tag) {
    if (vis[u] == tag) return false;
    vis[u] = tag;
    for (int e : g[u]) {
        if ((mch[e] == 0) || dfs(mch[e], tag)) {
            mch[e] = u;
            return true;
        }
    }
    return false;
}
int main() {
    ios_base::sync_with_stdio(false);cin.tie(0);cout.tie(0);
    cin >> n >> m >> t;
    while(t--) {
        int u,v;
        cin >> u >> v;
        g[u].push_back(v);
    }
    int ans = 0;
    for (int i = 1; i <= n; ++i){
        if (dfs(i, i)) {
            ans++;
        }
    }
    cout << ans << '\n';
}
```

## 二分图最大权完美匹配(KM算法)(未打印)

```c++
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N = 505;
ll n, m;
ll g[N][N];
ll s[N], pre[N], px[N];
ll vx[N], vy[N];
ll lx[N], ly[N];

void bfs(ll u) {
    for(int i = 1;i <= n;i++) {
        s[i] = 0x7ffffffffffff;
        pre[i] = vy[i] = 0;
    }
    ll y = 0;
    ll z = 0;
    px[y] = u;
    while(1) {
        ll x = px[y];
        ll d = 0x7ffffffffffff;
        vy[y] = 1;
        for(ll i = 1;i <= n;i++) {
            if(vy[i]) continue;
            if(s[i] > lx[x] + ly[i] - g[x][i]) {
                s[i] = lx[x] + ly[i] - g[x][i];
                pre[i] = y;
            }
            if(s[i] < d) {
                d = s[i];
                z = i;
            }
        }
        for(ll i = 0;i <= n;i++) {
            if(vy[i]) {
                lx[px[i]] -= d;
                ly[i] += d;
            }
            else s[i] -= d;
        }
        y = z;
        if(px[y] == 0)break;
    }
    while(y) {
        px[y] = px[pre[y]];
        y = pre[y];
    }
}

ll KM() {
    for(int i = 1;i <= n;i++) bfs(i);
    ll res = 0;
    for(int i = 1;i <= n;i++) {
        if(px[i] != -1) res += g[px[i]][i];
    }
    return res;
}

int main() {
    ios_base::sync_with_stdio(0);
    cin >> n >> m;
    for(int i = 1;i <= n;i++) {
        for(int j = 1;j <= n;j++) {
            g[i][j] = -0x7ffffffffffff;
        }
    }
    for(int i = 1;i <= m;i++) {
        ll u, v, w;
        cin >> u >> v >> w;
        g[u][v] = w;
    }
    cout << KM() << '\n';
    for(int i = 1;i <= n;i++) cout << px[i] << " \n"[i == n];
    return 0;
}
```



## 矩阵快速幂

```c++
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N = 305;
const int mod = 1e9 + 7;
ll n,m;
ll tmp[N][N];

void Multiply_Matrix(ll a[][N],ll b[][N]) {  // 矩阵乘法
    memset(tmp,0,sizeof tmp);
    for(int i = 1;i <= n;i++) {
        for(int j = 1;j <= n;j++) {
            for(int k = 1;k <= n;k++) {
                tmp[i][j] += a[i][k] * b[k][j];
                tmp[i][j] %= mod;
            }
        }
    }
    for(int i = 1;i <= n;i++) {
        for(int j = 1;j <= n;j++) {
            a[i][j] = tmp[i][j];
        }
    }
}

ll res[N][N];

void Fastpower_Matrix(ll a[][N],ll k) {   // 求矩阵 a 的 k 次幂
    memset(res,0,sizeof res);             // 结果矩阵
    for(int i = 1;i <= n;i++) res[i][i] = 1;
    while(k) {
        if(k & 1) Multiply_Matrix(res,a);
        Multiply_Matrix(a,a);
        k >>= 1;
    }
}

ll a[N][N];

int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    cin >> n >> m;
    for(int i = 1;i <= n;i++) {
        for(int j = 1;j <= n;j++) {
            cin >> a[i][j];
        }
    }
    Fastpower_Matrix(a,m);
    for(int i = 1;i <= n;i++) {
        for(int j = 1;j <= n;j++) {
            cout << res[i][j] << " \n"[j == n];
        }
    }
    return 0;
}

// 重构写法
struct Matrix {
    ll c[N][N];
} a,ans;

Matrix operator*(const Matrix &x,const Matrix &y) {    //  重载
    Matrix tmp;
    for(int i = 1;i <= n;i++) {
        for(int j = 1;j <= n;j++) {
            tmp.c[i][j] = 0;
        }
    }
    for(int i = 1;i <= n;i++) {
        for(int j = 1;j <= n;j++) {
            for(int k = 1;k <= n;k++) {
                tmp.c[i][j] += x.c[i][k] * y.c[k][j] % mod;
                tmp.c[i][j] %= mod;
            }
        }
    }
    return tmp;
}

void Fastpower_Matrix(ll k) {
    for(int i = 1;i <= n;i++)
        ans.c[i][i] = 1;                   //单位矩阵定义
    while(k) {                          //Fastpower_Matrix
        if(k & 1) ans = ans * a;
        a = a * a;
        k >>= 1;
    }
}
```

## 割点

```c++
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N = 1e5 + 5;
int low[N];            // low[u]表示顶点u及其子树中的点 通过非父子边(回边) 能够回溯到的最早的点(dfn最小)的dfn值(但不能通过连接u与其父节点的边)
int dfn[N];            // dfn[u]表示顶点u第几个被(首次)访问
int time_clock;
int cut[N];            // 判断是否为割点

struct yyy {
    int to,next;
} e[N << 1];
int head[N],tot;

void add(int u,int v) {
    e[++tot].to = v;
    e[tot].next = head[u];
    head[u] = tot;
}

void tarjan(int now,int fa) {
    dfn[now] = low[now] = ++time_clock;
    int child = 0;
    for(int i = head[now];i;i = e[i].next) {
        if(!dfn[e[i].to]) {
            tarjan(e[i].to,fa);
            low[now] = min(low[now],low[e[i].to]);
            if(low[e[i].to] >= dfn[now] && fa != now) cut[now] = 1;
            if(now == fa) child++;
        }
        low[now] = min(low[now],dfn[e[i].to]);
    }
    if(child >= 2 && fa == now) cut[fa] = 1;
}

int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    int i,n,m;
    cin >> n >> m;
    for(i = 1;i <= m;i++) {
        int u,v;
        cin >> u >> v;
        add(u,v);
        add(v,u);
    }
    for(i = 1;i <= n;i++) {
        if(dfn[i] == 0) tarjan(i,i);
    }
    int cnt = 0;
    for(i = 1;i <= n;i++) if(cut[i]) cnt++;
    cout << cnt << '\n';
    for(i = 1;i <= n;i++) {
        if(cut[i]) cout << i << ' ';
    }
    return 0;
}
```

## LCS(最长公共子序列)

```c++
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N = 3e3 + 5;    // 小数据范围
const int mod = 1e9 + 7;
string s1, s2;
int dp[N][N];
int pre[N][N];         // 存储路径

int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    cin >> s1 >> s2;
    int len1 = s1.length();
    int len2 = s2.length();
    s1 = " " + s1;
    s2 = " " + s2;     //  i == 0 || j == 0 时 dp[i][j] = 0;
    for(int i = 1;i <= len1;i++) {
        for(int j = 1;j <= len2;j++) {
            if(dp[i][j - 1] < dp[i - 1][j]) {
                dp[i][j] = dp[i - 1][j];
                pre[i][j] = 1;
            } else {
                dp[i][j] = dp[i][j - 1];
                pre[i][j] = 2;
            }
            if(s1[i] == s2[j] && dp[i - 1][j - 1] + 1 > dp[i][j]) {
                dp[i][j] = dp[i - 1][j - 1] + 1;
                pre[i][j] = 3;
            }
        }
    }
    cout << dp[len1][len2] << '\n';    // 输出长度
    int nowi = len1, nowj = len2;
    string ans = "";
    while(nowi && nowj) {
        if(pre[nowi][nowj] == 1)nowi--;
        else if(pre[nowi][nowj] == 2)nowj--;
        else ans += s1[nowi], nowi--, nowj--;
    }
    reverse(ans.begin(), ans.end());
    cout << ans;                      // 输出路径
    return 0;
}
```

## 素数和(Lucy hedgehog算法)

```c++
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;

ll check(ll v, ll n, ll m, ll size) {
    return v >= m ? n / v - 1 : (size - v);
}

// O(n^(3/4))
ll primenum(ll n) {   // 求1~n素数个数
    ll r = (ll) sqrt(n);
    ll ndr = n / r;
    ll nv = r + ndr - 1;
    std::vector<ll> s(nv + 1);   // 素数个数
    std::vector<ll> v(nv + 1);
    for(ll i = 0;i < r;i++) v[i] = n / (i + 1);
    for(ll i = r;i < nv;i++) v[i] = v[i - 1] - 1;
    for(ll i = 0;i < nv;i++) s[i] = v[i] - 1;
    for(ll p = 2;p <= r;p++) {
        if(s[nv - p] > s[nv - p + 1]) {
            ll sp = s[nv - p + 1];   // 小于p的素数和
            ll p2 = p * p;
            for(ll i = 0;i < nv;i++) {
                if(v[i] >= p2) {
                    s[i] -= 1LL * (s[check(v[i] / p, n, ndr, nv)] - sp);
                } else break;
            }
        }
    }
    return s[0];
}

ll primesum(ll n) {   //求1~n素数和
    ll r = (ll) sqrt(n);
    ll m = n / r;
    ll size = r + m - 1;
    vector<ll> s(size + 1);    //求素数和
    vector<ll> v(size + 1);
    for(ll i = 0;i < r;i++) v[i] = n / (i + 1);
    for(ll i = r;i < size;i++) v[i] = v[i - 1] - 1;
    for(ll i = 0;i < size;i++) s[i] = v[i] * (v[i] + 1) / 2 - 1;
    for(ll p = 2;p <= r;p++) {    // p 是一个素数
        if(s[size - p] > s[size - p + 1]) {
            ll sp = s[size - p + 1];    // 小于p的素数和
            ll p2 = p * p;
            for(ll i = 0;i < size;i++) {
                if(v[i] >= p2) {
                    s[i] -= p * (s[check(v[i] / p, n, m, size)] - sp);
                } else break;
            }
        }
    }
    return s[0];
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    ll T, n;
    cin >> T;
    while(T--) {
        cin >> n;
        cout << primenum(n) << ' ' << primesum(n) << '\n';
    }
    return 0;
}
```

## Miller_Rabin & Pollard_Rho(未打印)

```c++
ll qpow(ll a, ll b, ll mod) {    // 快速幂
    ll x = 1;
    while(b) {
        if(b & 1) x = (__int128) x * a % mod;
        a = (__int128) a * a % mod;
        b >>= 1;
    }
    return x;
}
bool Miller_Rabin(ll x) {
    if(x == 2) return true;
    for(int i = 0;i < 10;++i) {   // 随机测试次数 : 10
        ll a = rand() % (x - 2) + 2;
        if(qpow(a, x, x) != a)   // 注意 r已取 0
            return false;
    }
    return true;
}
bool mr(ll x, ll a) {  // Miller_Rabin 
    ll b = x - 1;
    while(b) {
        ll k = qpow(a, b, x);
        if(k != 1 && k != x - 1) return false;
        if(b & 1 || k == x - 1) return true;
        b >>= 1;
    }
    return true;
}
bool is_prime(ll x) {     // 判断是否为素数
    if(x == 46856248255981ll || x < 2) return false;
    if(x == 2 || x == 3 || x == 7 || x == 61 || x == 24251) return true;
    return mr(x, 2) && mr(x, 27) && mr(x, 61);
}


ll f(ll x, ll c, ll p) {
    return ((__int128)x * x + c) % p;
}
ll pr(ll x) {   // Pollard_Rho 返回一个 x 的因子
    ll t = 0;
    ll c = rand() % (x - 1) + 1;
    for(int goal = 1;;goal <<= 1) {
        ll s = t;
        ll val = 1;
        for(int step = 1;step <= goal;++step) {
            t = f(t, c, x);
            val = (__int128)val * abs(t - s) % x;
            if((step % 127) == 0) {
                ll d = __gcd(val, x);
                if(d > 1) return d;
            }
        }
        ll d = __gcd(val, x);
        if(d > 1) return d;
    }
}
```



## ST表

```c++
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N = 1e6 + 4;
int maxn[N][21];
int query(int l, int r) {
    int k = log2(r - l + 1);
    return max(maxn[l][k], maxn[r - (1 << k) + 1][k]);
}
int main() {
    ios_base::sync_with_stdio(false);cin.tie(0);cout.tie(0);
    int n, m;
    cin >> n >> m;
    for (int i = 1; i <= n; i++) cin >> maxn[i][0];
    for (int j = 1; j <= 21; j++)
        for (int i = 1; i + (1 << j) - 1 <= n; i++) 
            maxn[i][j] = max(maxn[i][j - 1], maxn[i + (1 << (j - 1))][j - 1]);
    while(m--) {
        int l, r;
        cin >> l >> r;
        cout << query(l, r) << '\n';
    }
    return 0;
}
```

## 质因数分解

```c++
#include <bits/stdc++.h>
using namespace std;
const int N = 2e6 + 5;
int net[N], x;

int main() {
    for(int i = 2;i < N;++i) {
        if(net[i] == 0) {
            net[i] = i;
            for(int j = i * i;j < N;j += i) {
                if(net[j] == 0) net[j] = i;
            }
        }
    }
    while(x > 1) {
        int div = net[x];   // div 为质数
        while(net[x] == div) {
            x /= div;
        }
    }
    return 0;
}
```

## 凸包(部分函数)

```c
struct point {
    double x, y;
};
bool mult(point sp, point ep, point op) {
    return (sp.x - op.x) * (ep.y - op.y) >= (ep.x - op.x) * (sp.y - op.y);
}
inline bool operator<(const point & l, const point & r) {
    return l.y < r.y || (l.y == r.y && l.x < r.x);
}
int graham(point pnt[], int n, point res[]) {
    int len, top = 1;
    sort(pnt, pnt + n);
    for(int i = 0;i <= 2;i++) {
        if(n == i) return i;
        res[i] = pnt[i];
    }
    for(int i = 2;i < n;i++) {
        while(top && mult(pnt[i], res[top], res[top - 1])) top--;
        res[++top] = pnt[i];
    }
    len = top;
    res[++top] = pnt[n - 2];
    for(int i = n - 3;i >= 0;i--) {
        while(top != len && mult(pnt[i], res[top], res[top - 1])) {
            top--;
        }
        res[++top] = pnt[i];
    }
    return top; //  返回凸包中点的个数
}
```

## 中国剩余定理

```c++
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N = 1e6 + 5;
void ex_gcd(ll a, ll b, ll& x, ll& y) {  // ax = 1 (mod b)    x 为 a 的逆元
    if (b == 0) {
        x = 1, y = 0;
        return;
    }
    ex_gcd(b, a % b, y, x);
    y -= a / b * x;
}
ll a[N], b[N], n;
int main() {          // num % b[i] = a[i]  求最小的 num
    ios_base::sync_with_stdio(false);
    cin >> n;
    ll mul = 1;
    for(int i = 1;i <= n;i++) cin >> a[i];
    for(int i = 1;i <= n;i++) cin >> b[i]; // b[i] 两两互质
    for(int i = 1;i <= n;i++) mul *= b[i];
    ll ans = 0, x, y;
    for(int i = 1;i <= n;i++) {
        ll k = mul / b[i];
        ex_gcd(k, b[i], x, y);
        x = (x % b[i] + b[i]) % b[i];
        ans = (ans + (__int128)a[i] % mul * k % mul * x % mul) % mul;
    }
    cout << ans;
    return 0;
}
```

## 扩展中国剩余定理

```c++
#include<bits/stdc++.h>
using namespace std;
typedef __int128 ll;         //注意__int128
const int N = 2e6 + 5;
ll ex_gcd(ll a, ll b, ll& x, ll& y) {
    if (b == 0) {
        x = 1;
        y = 0;
        return a;
    }
    ll d = ex_gcd(b, a % b, x, y);
    ll temp = x;
    x = y;
    y = temp - a / b * y;
    return d;
}
long long a[N], b[N], n;

int main() {
    ios_base::sync_with_stdio(false);
    cin >> n;
    for(int i = 1;i <= n;i++) cin >> a[i] >> b[i];  // b[i] 不要求两两互质
    ll x, y;
    ll M = b[1];
    ll ans = a[1];
    for(int i = 2;i <= n;i++) {
        ll aa = M;
        ll bb = b[i];
        ll cc = (a[i] - ans % bb + bb) % bb;
        ll d = ex_gcd(aa, bb, x, y);
        if(cc % d) {    // 无解
            cout << "NO";
            return 0;
        }
        ll k = bb / d;
        ll t = cc / d;
        x = x * t % k;
        ans += x * M;
        M *= k;
        ans = (ans % M + M) % M;
    }
    cout << (long long)ans;
    return 0;
}
```

## BSGS——求 $a ^ {ans} = b\ (mod\ p),\ gcd(a, p) = 1$

```c++
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N = 1e6 + 5;

ll kpow(ll a, ll b, ll p) {
    ll x = 1;
    while(b) {
        if(b & 1) x = x * a % p;
        a = a * a % p;
        b >>= 1;
    }
    return x;
}
map<ll, ll> mp;

ll BSGS(ll a, ll b, ll p) {
    a %= p;b %= p;
    if(b == 1 || p == 1) return 0;
    if(!a) {
        if(b) return -1;
        return 1;
    }
    mp.clear();
    ll k = sqrt(p);
    while(k * k < p) k++;
    ll res = b;
    for(int i = 1;i <= k;i++) {
        res = res * a % p;
        mp[res] = i;
    }
    ll kp = kpow(a, k, p);
    res = 1;
    for(int i = 1;i <= k;i++) {
        res = res * kp % p;
        if(mp[res]) return (i * k - mp[res] + p) % p;
    }
    return -1;
}
ll a, b, p;
int main() {
    ios_base::sync_with_stdio(false);
    cin >> a >> b >> p;
    ll ans = BSGS(a, b, p);
    if(ans == -1) cout << "no solution" << '\n';
    else cout << ans << '\n';
    return 0;
}
```

## 扩展BSGS

```c++
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int MAXINT = ((1 << 30) - 1) * 2 + 1;
struct Hashmap {
    static const int Ha = 999917, M = 46340;
    int e, lnk[Ha], son[M + 5], nxt[M + 5], w[M + 5];
    int top, stk[M + 5];

    void clear() {
        e = 0;
        while(top) lnk[stk[top--]] = 0;
    }

    void Add(int x, int y) {
        son[++e] = y;
        nxt[e] = lnk[x];
        w[e] = MAXINT;
        lnk[x] = e;
    }

    bool count(int y) {
        int x = y % Ha;
        for(int j = lnk[x];j;j = nxt[j])
            if(y == son[j]) return true;
        return false;
    }

    int & operator[](int y) {
        int x = y % Ha;
        for(int j = lnk[x];j;j = nxt[j]) {
            if(y == son[j]) return w[j];
        }
        Add(x, y);
        stk[++top] = x;
        return w[e];
    }
} f;

void exgcd(ll a, ll b, ll & x, ll & y) {
    if(!b) {
        x = 1;
        y = 0;
        return;
    }
    exgcd(b, a % b, x, y);
    ll t = x;
    x = y;
    y = t - a / b * y;
}

ll kpow(ll a, ll b, ll p) {
    ll x = 1;
    while(b) {
        if(b & 1) x = x * a % p;
        a = a * a % p;
        b >>= 1;
    }
    return x;
}

ll BSGS(ll a, ll b, ll p, ll d) {
    f.clear();
    ll k = sqrt(p);
    while(k * k < p) k++;
    ll res = 1;
    for(int i = 0;i < k;i++) {
        f[res] = min(f[res], i);
        res = res * a % p;
    }
    for(int i = 0;i < k;i++) {
        ll x, y;
        exgcd(d, p, x, y);
        x = (x * b % p + p) % p;
        if(f.count(x)) return i * k + f[x];
        d = (d * res) % p;
    }
    return -1;
}

ll EXBSGS(ll a, ll b, ll p) {
    if(b == 1 || p == 1) return 0;     //特殊情况，x = 0 时最小解
    ll g, d = 1, num = 0;
    while((g = __gcd(a, p)) > 1) {  //把a, c变成 (a,c) = 1 为止
        if(b % g) return -1;
        num++;
        b /= g;
        p /= g;
        d = (d * a / g) % p; //将多出来的乘给 d
        if(d == b) return num;
    }
    ll ans = BSGS(a, b, p, d);
    if(ans == -1) return -1;
    return ans + num;
}

int main() {
    ios_base::sync_with_stdio(0);
    ll a, b, p;
    cin >> a >> b >> p;
    a %= p;b %= p;
    ll ans = EXBSGS(a, b, p);
    if(ans == -1) cout << "no solution\n";  // 无结果
    else cout << ans << '\n';
    return 0;
}
```

## 欧拉函数

#### ①$\large \phi(n)=n\prod_{i=1}^{n}\frac{p_i-1}{p_i}\ |\ p_i为质因子$

```c++
ll eular(ll n) {          // sqrt(n) 求欧拉函数
    ll ans = n;
    ll k = sqrt(n);
    for(int i = 2;i <= k;i++) {
        if(n % i == 0) {
            ans = ans / i * (i - 1);
            while(n % i == 0) n /= i;
        }
    }
    if(n > 1) ans = ans / n * (n - 1);
    return ans;
}
```

#### ②欧拉筛预处理欧拉函数

欧拉函数的一些性质：
① 当 $\large gcd(m,n)=1$ 时，有 $\large\phi(m*n)= \phi(m)*\phi(n)$

② 若 $\large i\ mod\ p=0$，有 $\large\phi(i*p) = p * \phi(i)$

③ 当 $\large gcd(x,p)=1$ 时，有$\large x ^{\phi(p)}≡1(mod\ p)$，因此x的逆元为 $\large x^ {\phi(p)-1}$，即欧拉定理
特别地，当p为质数时，$\large \phi(p)=p-1$,此时逆元为 $\large x^{p-2}$，即费马小定理

④ 当 $\large n$ 为奇数时，$\large\ phi(2n)=\phi(n)$

⑤ 当 $\large gcd(x,n)=1$ ，则有 $\large gcd(n-x,n)=1$ 

⑥ $\large n>1$，不大于 $\large n$ 且和 $\large n$ 互素的所有正整数的和是 $\large \frac{1}{2} *n*\phi(n)$，即 $\large\sum _{i=1}^{n}i| \ _{gcd(i,n) = 1}=\frac{1}{2} *n*\phi(n)$

⑦若$\large n\ mod\ a = 0\  \&\&\ (n/a)\ mod\ a=0$，则有 $\large \phi(n)=\phi(n/a)*a$

⑧若$\large n\ mod\ a=0\ \&\&\ (n/a)\ mod \ a\neq 0$，则有 $\large\ phi(n)=\phi(n/a)*(a-1)$

## 欧拉降幂

$\large a^b(mod \ p)= \begin{cases} a^{b\% \phi(p)}, & {gcd(a,p)=1} \\ a^b, & {gcd(a,p)\neq 1，b<phi(p)} \\ a^{b\% \phi(p) + \phi(p)}, & {gcd(a,p)\neq1，b\geq phi(p) } \end{cases}$

